/* This file has been generated automatically.
   Please do not modify it, edit the m4 scripts instead. */

#include "config.h"

#if ARCH != ARCH_HOST
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sleep.h>
#include <avr/wdt.h>
#endif

#include <stdint.h>
#include "core/debug.h"
#include "services/freqcount/freqcount.h"

#if ARCH == ARCH_HOST
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include "core/host/tap.h"
#include "core/host/stdin.h"

/* for C-c exit handler */
#include <signal.h>
#include <stdlib.h>
void ethersex_meta_exit (int signal);

#endif

void dyndns_update(void);
void periodic_process(void);
volatile uint8_t newtick;

/* This file has been generated by ecmd_defs.m4 automatically.
   Please do not modify it, edit the m4 scripts instead. */

#include <avr/pgmspace.h>
#include "protocols/ecmd/parser.h"

#ifndef NULL
#define NULL ((void *) 0)
#endif

#include "network.h"
#include "core/periodic.h"
#include "core/vfs/vfs.h"
#include "hardware/adc/adc.h"
#include "hardware/ethernet/enc28j60.h"
#include "hardware/ethernet/enc28j60.h"
#include "hardware/onewire/onewire.h"
#include "protocols/ems/ems.h"
#include "protocols/ems/ems.h"
#include "protocols/uip/uip.h"
#include "protocols/uip/uip_router.h"
#include "protocols/uip/uip_arp.h"
#include "protocols/ecmd/via_tcp/ecmd_net.h"
#include "services/clock/clock.h"
#include "services/httpd/httpd.h"


/* This is just to make the inversion more visible. */
#define INVERT(a) (!(a))

#define NP_PORT(a) (PORT ## a)
#define NP_PIN(a) (PIN ## a)
#define NP_DDR(a) (DDR ## a)

#ifndef SOAP_SUPPORT
#define soap_rpc(a,b)	/* no soap */
#endif  /* SOAP_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
const char PROGMEM np_str_on[] = "on";
const char PROGMEM np_str_off[] = "off";

static int8_t
np_simple_check (char *cmd)
{
  /* Check for either pin set ... 1 or pin set ... on,
     for reasons of simplicity we simply check for the 1 or the
     n of on. */
  if (cmd[0] == '1' || cmd[1] == 'n')
    return 1;
  else if (cmd[0] == '0' || cmd[1] == 'f')
    return 0;

  return -1;
}

#define REPLY(output,state) do {                               \
  uint8_t plen = state ? 2 : 3;                                        \
  memcpy_P (output, state ? np_str_on : np_str_off, plen);     \
  return plen;                                                 \
} while(0)
#endif  /* ECMD_PARSER_SUPPORT */




#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_out_p1 (char *cmd, char *output, uint16_t len)
{
  /* config: PA0  */
  int8_t i = np_simple_check (cmd);
  if (i < 0) return -1;

  if ((i))
    NP_PORT(A) |= _BV(PA0);
  else
    NP_PORT(A) &= ~_BV(PA0);

  REPLY (output, i);
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_in_p1 (char *cmd, char *output, uint16_t len)
{
  /* config: PA0  */
  uint8_t i = NP_PIN(A) & _BV(PA0);
  REPLY (output, (i));
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_toggle_p1 (char *cmd, char *output, uint16_t len)
{
  /* config: PA0  */

#ifdef PINx_TOGGLE_WORKAROUND
  /* We cannot toggle the pin by writing to the PINx register, therefore
     we have to do a read, xor, write with interrupts disabled to make
     sure noone interferes ...
     Furthermore we have to check whether the pin really is configured
     as output, to not accidentally toggle the internal pull-up resistor. */

  if ((NP_DDR(A) & _BV(PA0)) == 0)
    return -1;   		/* Configured as input, stop. */

  /* Disable interrupts to omit interference */
  uint8_t sreg = SREG; cli();

  uint8_t i = NP_PORT(A);
  NP_PORT(A) = i  ^ _BV(PA0);

  SREG = sreg;			/* Possibly re-enable interrupts. */
#else  /* PINx_TOGGLE_WORKAROUND */
  /* First we read the current pin-state and afterwards toggle
     the pin by writing to the PINx register. */
  uint8_t i = NP_PORT(A);

  /* now toggle the port */
  NP_PIN(A) |= _BV(PA0);
#endif  /* not PINx_TOGGLE_WORKAROUND */

  /* say just the opposite of the old situation ... */
  REPLY (output, !(i & _BV(PA0)));
}
#endif  /* ECMD_PARSER_SUPPORT */


soap_rpc(soap_rpc_np_simple_out_p1, "p1")
#ifdef SOAP_SUPPORT
uint8_t soap_rpc_np_simple_out_p1 (uint8_t len, soap_data_t *args, soap_data_t *result)
{
  result->type = SOAP_TYPE_INT;

  /* config: PA0  */
  if (len == 0) {
    /* read */
    uint8_t i = NP_PIN(A) & _BV(PA0);
    result->u.d_int = (i) != 0;
  }
  else if (len == 1 && args[0].type == SOAP_TYPE_INT) {
    /* write */
    if ((args[0].u.d_int))
      NP_PORT(A) |= _BV(PA0);
    else
      NP_PORT(A) &= ~_BV(PA0);
    result->u.d_int = args[0].u.d_int != 0;
  }
  else
    return 1;		/* fuck off */

  return 0;
}
#endif  /* SOAP_SUPPORT */



#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_out_p2 (char *cmd, char *output, uint16_t len)
{
  /* config: PA1  */
  int8_t i = np_simple_check (cmd);
  if (i < 0) return -1;

  if ((i))
    NP_PORT(A) |= _BV(PA1);
  else
    NP_PORT(A) &= ~_BV(PA1);

  REPLY (output, i);
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_in_p2 (char *cmd, char *output, uint16_t len)
{
  /* config: PA1  */
  uint8_t i = NP_PIN(A) & _BV(PA1);
  REPLY (output, (i));
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_toggle_p2 (char *cmd, char *output, uint16_t len)
{
  /* config: PA1  */

#ifdef PINx_TOGGLE_WORKAROUND
  /* We cannot toggle the pin by writing to the PINx register, therefore
     we have to do a read, xor, write with interrupts disabled to make
     sure noone interferes ...
     Furthermore we have to check whether the pin really is configured
     as output, to not accidentally toggle the internal pull-up resistor. */

  if ((NP_DDR(A) & _BV(PA1)) == 0)
    return -1;   		/* Configured as input, stop. */

  /* Disable interrupts to omit interference */
  uint8_t sreg = SREG; cli();

  uint8_t i = NP_PORT(A);
  NP_PORT(A) = i  ^ _BV(PA1);

  SREG = sreg;			/* Possibly re-enable interrupts. */
#else  /* PINx_TOGGLE_WORKAROUND */
  /* First we read the current pin-state and afterwards toggle
     the pin by writing to the PINx register. */
  uint8_t i = NP_PORT(A);

  /* now toggle the port */
  NP_PIN(A) |= _BV(PA1);
#endif  /* not PINx_TOGGLE_WORKAROUND */

  /* say just the opposite of the old situation ... */
  REPLY (output, !(i & _BV(PA1)));
}
#endif  /* ECMD_PARSER_SUPPORT */


soap_rpc(soap_rpc_np_simple_out_p2, "p2")
#ifdef SOAP_SUPPORT
uint8_t soap_rpc_np_simple_out_p2 (uint8_t len, soap_data_t *args, soap_data_t *result)
{
  result->type = SOAP_TYPE_INT;

  /* config: PA1  */
  if (len == 0) {
    /* read */
    uint8_t i = NP_PIN(A) & _BV(PA1);
    result->u.d_int = (i) != 0;
  }
  else if (len == 1 && args[0].type == SOAP_TYPE_INT) {
    /* write */
    if ((args[0].u.d_int))
      NP_PORT(A) |= _BV(PA1);
    else
      NP_PORT(A) &= ~_BV(PA1);
    result->u.d_int = args[0].u.d_int != 0;
  }
  else
    return 1;		/* fuck off */

  return 0;
}
#endif  /* SOAP_SUPPORT */



#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_out_p3 (char *cmd, char *output, uint16_t len)
{
  /* config: PA2  */
  int8_t i = np_simple_check (cmd);
  if (i < 0) return -1;

  if ((i))
    NP_PORT(A) |= _BV(PA2);
  else
    NP_PORT(A) &= ~_BV(PA2);

  REPLY (output, i);
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_in_p3 (char *cmd, char *output, uint16_t len)
{
  /* config: PA2  */
  uint8_t i = NP_PIN(A) & _BV(PA2);
  REPLY (output, (i));
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_toggle_p3 (char *cmd, char *output, uint16_t len)
{
  /* config: PA2  */

#ifdef PINx_TOGGLE_WORKAROUND
  /* We cannot toggle the pin by writing to the PINx register, therefore
     we have to do a read, xor, write with interrupts disabled to make
     sure noone interferes ...
     Furthermore we have to check whether the pin really is configured
     as output, to not accidentally toggle the internal pull-up resistor. */

  if ((NP_DDR(A) & _BV(PA2)) == 0)
    return -1;   		/* Configured as input, stop. */

  /* Disable interrupts to omit interference */
  uint8_t sreg = SREG; cli();

  uint8_t i = NP_PORT(A);
  NP_PORT(A) = i  ^ _BV(PA2);

  SREG = sreg;			/* Possibly re-enable interrupts. */
#else  /* PINx_TOGGLE_WORKAROUND */
  /* First we read the current pin-state and afterwards toggle
     the pin by writing to the PINx register. */
  uint8_t i = NP_PORT(A);

  /* now toggle the port */
  NP_PIN(A) |= _BV(PA2);
#endif  /* not PINx_TOGGLE_WORKAROUND */

  /* say just the opposite of the old situation ... */
  REPLY (output, !(i & _BV(PA2)));
}
#endif  /* ECMD_PARSER_SUPPORT */


soap_rpc(soap_rpc_np_simple_out_p3, "p3")
#ifdef SOAP_SUPPORT
uint8_t soap_rpc_np_simple_out_p3 (uint8_t len, soap_data_t *args, soap_data_t *result)
{
  result->type = SOAP_TYPE_INT;

  /* config: PA2  */
  if (len == 0) {
    /* read */
    uint8_t i = NP_PIN(A) & _BV(PA2);
    result->u.d_int = (i) != 0;
  }
  else if (len == 1 && args[0].type == SOAP_TYPE_INT) {
    /* write */
    if ((args[0].u.d_int))
      NP_PORT(A) |= _BV(PA2);
    else
      NP_PORT(A) &= ~_BV(PA2);
    result->u.d_int = args[0].u.d_int != 0;
  }
  else
    return 1;		/* fuck off */

  return 0;
}
#endif  /* SOAP_SUPPORT */



#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_out_p4 (char *cmd, char *output, uint16_t len)
{
  /* config: PA3  */
  int8_t i = np_simple_check (cmd);
  if (i < 0) return -1;

  if ((i))
    NP_PORT(A) |= _BV(PA3);
  else
    NP_PORT(A) &= ~_BV(PA3);

  REPLY (output, i);
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_in_p4 (char *cmd, char *output, uint16_t len)
{
  /* config: PA3  */
  uint8_t i = NP_PIN(A) & _BV(PA3);
  REPLY (output, (i));
}
#endif  /* ECMD_PARSER_SUPPORT */

#ifdef ECMD_PARSER_SUPPORT
int16_t parse_cmd_np_simple_toggle_p4 (char *cmd, char *output, uint16_t len)
{
  /* config: PA3  */

#ifdef PINx_TOGGLE_WORKAROUND
  /* We cannot toggle the pin by writing to the PINx register, therefore
     we have to do a read, xor, write with interrupts disabled to make
     sure noone interferes ...
     Furthermore we have to check whether the pin really is configured
     as output, to not accidentally toggle the internal pull-up resistor. */

  if ((NP_DDR(A) & _BV(PA3)) == 0)
    return -1;   		/* Configured as input, stop. */

  /* Disable interrupts to omit interference */
  uint8_t sreg = SREG; cli();

  uint8_t i = NP_PORT(A);
  NP_PORT(A) = i  ^ _BV(PA3);

  SREG = sreg;			/* Possibly re-enable interrupts. */
#else  /* PINx_TOGGLE_WORKAROUND */
  /* First we read the current pin-state and afterwards toggle
     the pin by writing to the PINx register. */
  uint8_t i = NP_PORT(A);

  /* now toggle the port */
  NP_PIN(A) |= _BV(PA3);
#endif  /* not PINx_TOGGLE_WORKAROUND */

  /* say just the opposite of the old situation ... */
  REPLY (output, !(i & _BV(PA3)));
}
#endif  /* ECMD_PARSER_SUPPORT */


soap_rpc(soap_rpc_np_simple_out_p4, "p4")
#ifdef SOAP_SUPPORT
uint8_t soap_rpc_np_simple_out_p4 (uint8_t len, soap_data_t *args, soap_data_t *result)
{
  result->type = SOAP_TYPE_INT;

  /* config: PA3  */
  if (len == 0) {
    /* read */
    uint8_t i = NP_PIN(A) & _BV(PA3);
    result->u.d_int = (i) != 0;
  }
  else if (len == 1 && args[0].type == SOAP_TYPE_INT) {
    /* write */
    if ((args[0].u.d_int))
      NP_PORT(A) |= _BV(PA3);
    else
      NP_PORT(A) &= ~_BV(PA3);
    result->u.d_int = args[0].u.d_int != 0;
  }
  else
    return 1;		/* fuck off */

  return 0;
}
#endif  /* SOAP_SUPPORT */



/* Function 0 follow */
int16_t parse_cmd_d (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_fuse (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_hostname (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_reset (char *cmd, char *output, uint16_t len);
#ifndef TEENSY_SUPPORT
int16_t parse_cmd_wdreset (char *cmd, char *output, uint16_t len);
#endif
int16_t parse_cmd_io (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_adc_get (char *cmd, char *output, uint16_t len);
#ifdef ADC_VOLTAGE_SUPPORT
int16_t parse_cmd_adc_vget (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_adc_vref (char *cmd, char *output, uint16_t len);
#endif
int16_t parse_cmd_mac (char *cmd, char *output, uint16_t len);
#ifdef DEBUG_ENC28J60
int16_t parse_cmd_enc_dump (char *cmd, char *output, uint16_t len);
#endif
#ifdef ONEWIRE_DETECT_SUPPORT
int16_t parse_cmd_onewire_list (char *cmd, char *output, uint16_t len);
#endif
#ifdef ONEWIRE_NAMING_SUPPORT
int16_t parse_cmd_onewire_get (char *cmd, char *output, uint16_t len);
#else
int16_t parse_cmd_onewire_get (char *cmd, char *output, uint16_t len);
#endif
int16_t parse_cmd_onewire_convert (char *cmd, char *output, uint16_t len);
#ifdef ONEWIRE_NAMING_SUPPORT
int16_t parse_cmd_onewire_name_set (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_onewire_name_clear (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_onewire_name_list (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_onewire_name_save (char *cmd, char *output, uint16_t len);
#endif
#ifdef EMS_DEBUG_STATS
int16_t parse_cmd_ems_stats (char *cmd, char *output, uint16_t len);
#endif
#ifndef TEENSY_SUPPORT
#ifdef UIP_SUPPORT
#ifndef IPV6_SUPPORT
int16_t parse_cmd_netmask (char *cmd, char *output, uint16_t len);
#endif
int16_t parse_cmd_ip (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_gw (char *cmd, char *output, uint16_t len);
#endif
#endif
int16_t parse_cmd_date (char *cmd, char *output, uint16_t len);
#ifdef DCF77_SUPPORT
int16_t parse_cmd_lastdcf (char *cmd, char *output, uint16_t len);
#endif
int16_t parse_cmd_time (char *cmd, char *output, uint16_t len);
#ifndef TEENSY_SUPPORT
int16_t parse_cmd_help (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_version (char *cmd, char *output, uint16_t len);
#endif
#ifdef FREE_SUPPORT
int16_t parse_cmd_free (char *cmd, char *output, uint16_t len);
#endif
#ifdef EEPROM_SUPPORT
int16_t parse_cmd_eeprom_reinit (char *cmd, char *output, uint16_t len);
#endif
int16_t parse_cmd_np_simple_out_p1 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_in_p1 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_toggle_p1 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_out_p2 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_in_p2 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_toggle_p2 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_out_p3 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_in_p3 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_toggle_p3 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_out_p4 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_in_p4 (char *cmd, char *output, uint16_t len);
int16_t parse_cmd_np_simple_toggle_p4 (char *cmd, char *output, uint16_t len);

/* Char array definitions follow */
const char PROGMEM ecmd_d_text[] = "d ";
const char PROGMEM ecmd_fuse_text[] = "fuse";
const char PROGMEM ecmd_hostname_text[] = "hostname";
const char PROGMEM ecmd_reset_text[] = "reset";
#ifndef TEENSY_SUPPORT
const char PROGMEM ecmd_wdreset_text[] = "wdreset";
#endif
const char PROGMEM ecmd_io_text[] = "io";
const char PROGMEM ecmd_adc_get_text[] = "adc get";
#ifdef ADC_VOLTAGE_SUPPORT
const char PROGMEM ecmd_adc_vget_text[] = "adc vget";
const char PROGMEM ecmd_adc_vref_text[] = "adc vref";
#endif
const char PROGMEM ecmd_mac_text[] = "mac";
#ifdef DEBUG_ENC28J60
const char PROGMEM ecmd_enc_dump_text[] = "enc dump";
#endif
#ifdef ONEWIRE_DETECT_SUPPORT
const char PROGMEM ecmd_onewire_list_text[] = "1w list";
#endif
#ifdef ONEWIRE_NAMING_SUPPORT
const char PROGMEM ecmd_onewire_get_text[] = "1w get";
#else
const char PROGMEM ecmd_onewire_get_text[] = "1w get";
#endif
const char PROGMEM ecmd_onewire_convert_text[] = "1w convert";
#ifdef ONEWIRE_NAMING_SUPPORT
const char PROGMEM ecmd_onewire_name_set_text[] = "1w name set";
const char PROGMEM ecmd_onewire_name_clear_text[] = "1w name clear";
const char PROGMEM ecmd_onewire_name_list_text[] = "1w name list";
const char PROGMEM ecmd_onewire_name_save_text[] = "1w name save";
#endif
#ifdef EMS_DEBUG_STATS
const char PROGMEM ecmd_ems_stats_text[] = "ems stats";
#endif
#ifndef TEENSY_SUPPORT
#ifdef UIP_SUPPORT
#ifndef IPV6_SUPPORT
const char PROGMEM ecmd_netmask_text[] = "netmask";
#endif
const char PROGMEM ecmd_ip_text[] = "ip";
const char PROGMEM ecmd_gw_text[] = "gw";
#endif
#endif
const char PROGMEM ecmd_date_text[] = "date";
#ifdef DCF77_SUPPORT
const char PROGMEM ecmd_lastdcf_text[] = "lastdcf";
#endif
const char PROGMEM ecmd_time_text[] = "time";
#ifndef TEENSY_SUPPORT
const char PROGMEM ecmd_help_text[] = "help";
const char PROGMEM ecmd_version_text[] = "version";
#endif
#ifdef FREE_SUPPORT
const char PROGMEM ecmd_free_text[] = "free";
#endif
#ifdef EEPROM_SUPPORT
const char PROGMEM ecmd_eeprom_reinit_text[] = "eeprom reinit";
#endif
const char PROGMEM ecmd_np_simple_out_p1_text[] = "pin set p1 ";
const char PROGMEM ecmd_np_simple_in_p1_text[] = "pin get p1";
const char PROGMEM ecmd_np_simple_toggle_p1_text[] = "pin toggle p1";
const char PROGMEM ecmd_np_simple_out_p2_text[] = "pin set p2 ";
const char PROGMEM ecmd_np_simple_in_p2_text[] = "pin get p2";
const char PROGMEM ecmd_np_simple_toggle_p2_text[] = "pin toggle p2";
const char PROGMEM ecmd_np_simple_out_p3_text[] = "pin set p3 ";
const char PROGMEM ecmd_np_simple_in_p3_text[] = "pin get p3";
const char PROGMEM ecmd_np_simple_toggle_p3_text[] = "pin toggle p3";
const char PROGMEM ecmd_np_simple_out_p4_text[] = "pin set p4 ";
const char PROGMEM ecmd_np_simple_in_p4_text[] = "pin get p4";
const char PROGMEM ecmd_np_simple_toggle_p4_text[] = "pin toggle p4";

/* Definition of function pointer array follows */
const struct ecmd_command_t PROGMEM ecmd_cmds[] = {
	{ ecmd_d_text, parse_cmd_d },
	{ ecmd_fuse_text, parse_cmd_fuse },
	{ ecmd_hostname_text, parse_cmd_hostname },
	{ ecmd_reset_text, parse_cmd_reset },
#ifndef TEENSY_SUPPORT
	{ ecmd_wdreset_text, parse_cmd_wdreset },
#endif
	{ ecmd_io_text, parse_cmd_io },
	{ ecmd_adc_get_text, parse_cmd_adc_get },
#ifdef ADC_VOLTAGE_SUPPORT
	{ ecmd_adc_vget_text, parse_cmd_adc_vget },
	{ ecmd_adc_vref_text, parse_cmd_adc_vref },
#endif
	{ ecmd_mac_text, parse_cmd_mac },
#ifdef DEBUG_ENC28J60
	{ ecmd_enc_dump_text, parse_cmd_enc_dump },
#endif
#ifdef ONEWIRE_DETECT_SUPPORT
	{ ecmd_onewire_list_text, parse_cmd_onewire_list },
#endif
#ifdef ONEWIRE_NAMING_SUPPORT
	{ ecmd_onewire_get_text, parse_cmd_onewire_get },
#else
	{ ecmd_onewire_get_text, parse_cmd_onewire_get },
#endif
	{ ecmd_onewire_convert_text, parse_cmd_onewire_convert },
#ifdef ONEWIRE_NAMING_SUPPORT
	{ ecmd_onewire_name_set_text, parse_cmd_onewire_name_set },
	{ ecmd_onewire_name_clear_text, parse_cmd_onewire_name_clear },
	{ ecmd_onewire_name_list_text, parse_cmd_onewire_name_list },
	{ ecmd_onewire_name_save_text, parse_cmd_onewire_name_save },
#endif
#ifdef EMS_DEBUG_STATS
	{ ecmd_ems_stats_text, parse_cmd_ems_stats },
#endif
#ifndef TEENSY_SUPPORT
#ifdef UIP_SUPPORT
#ifndef IPV6_SUPPORT
	{ ecmd_netmask_text, parse_cmd_netmask },
#endif
	{ ecmd_ip_text, parse_cmd_ip },
	{ ecmd_gw_text, parse_cmd_gw },
#endif
#endif
	{ ecmd_date_text, parse_cmd_date },
#ifdef DCF77_SUPPORT
	{ ecmd_lastdcf_text, parse_cmd_lastdcf },
#endif
	{ ecmd_time_text, parse_cmd_time },
#ifndef TEENSY_SUPPORT
	{ ecmd_help_text, parse_cmd_help },
	{ ecmd_version_text, parse_cmd_version },
#endif
#ifdef FREE_SUPPORT
	{ ecmd_free_text, parse_cmd_free },
#endif
#ifdef EEPROM_SUPPORT
	{ ecmd_eeprom_reinit_text, parse_cmd_eeprom_reinit },
#endif
	{ ecmd_np_simple_out_p1_text, parse_cmd_np_simple_out_p1 },
	{ ecmd_np_simple_in_p1_text, parse_cmd_np_simple_in_p1 },
	{ ecmd_np_simple_toggle_p1_text, parse_cmd_np_simple_toggle_p1 },
	{ ecmd_np_simple_out_p2_text, parse_cmd_np_simple_out_p2 },
	{ ecmd_np_simple_in_p2_text, parse_cmd_np_simple_in_p2 },
	{ ecmd_np_simple_toggle_p2_text, parse_cmd_np_simple_toggle_p2 },
	{ ecmd_np_simple_out_p3_text, parse_cmd_np_simple_out_p3 },
	{ ecmd_np_simple_in_p3_text, parse_cmd_np_simple_in_p3 },
	{ ecmd_np_simple_toggle_p3_text, parse_cmd_np_simple_toggle_p3 },
	{ ecmd_np_simple_out_p4_text, parse_cmd_np_simple_out_p4 },
	{ ecmd_np_simple_in_p4_text, parse_cmd_np_simple_in_p4 },
	{ ecmd_np_simple_toggle_p4_text, parse_cmd_np_simple_toggle_p4 },
        { NULL, NULL }
};
void
ethersex_meta_init (void)
{
#if ARCH == ARCH_HOST
    signal(SIGINT, ethersex_meta_exit);
#endif

    network_init ();
    periodic_init ();
    adc_init ();
    onewire_init ();
    clock_init ();
}  /* End of ethersex_meta_init. */

void
ethersex_meta_netinit (void)
{
#   if defined(DYNDNS_SUPPORT) && !defined(BOOTP_SUPPORT) \
      && ((!defined(IPV6_SUPPORT)) || defined(IPV6_STATIC_SUPPORT))
    dyndns_update();
#   endif

    init_enc28j60 ();
    ems_init ();
    ems_net_init ();
    ecmd_net_init ();
    httpd_init ();
} /* End of ethersex_meta_netinit. */

#if ARCH == ARCH_HOST
void
ethersex_meta_exit (int signal)
{
    if (signal != SIGINT) return;
    printf ("Shutting down Ethersex ...\n");
    exit(0);
} /* End of ethersex_meta_exit. */
#endif  /* ARCH == ARCH_HOST */


void
ethersex_meta_startup (void)
{

}  /* End of ethersex_meta_startup. */

void
ethersex_meta_mainloop (void)
{

    network_process (); wdt_kick ();
    ems_process (); wdt_kick ();
    periodic_process(); wdt_kick();

#ifdef FREQCOUNT_SUPPORT
    freqcount_mainloop();
#endif

#ifdef CPU_SLEEP
/* Works only if there are interrupts enabled, e.g. from periodic.c */
        set_sleep_mode(SLEEP_MODE_IDLE);
        sleep_mode();
#endif
}


void periodic_process(void)
{
    static uint16_t counter = 0;
#if ARCH == ARCH_HOST
    {
	fd_set fds;
	struct timeval tv = { .tv_sec = 0, .tv_usec = 20000 };

	FD_ZERO (&fds);
#ifdef ECMD_PARSER_SUPPORT
	FD_SET (0, &fds);
#endif  /* ECMD_PARSER_SUPPORT */
	FD_SET (tap_fd, &fds);
	select (tap_fd + 1, &fds, NULL, NULL, &tv);

#ifdef ECMD_PARSER_SUPPORT
	if (FD_ISSET (0, &fds))
	   stdin_read ();
#endif  /* ECMD_PARSER_SUPPORT */

	if (FD_ISSET (tap_fd, &fds))
	   tap_read ();

#else
    if (newtick) {
        newtick=0;
#endif
        counter++;
#ifdef UIP_SUPPORT
        if (uip_buf_lock ()) {
#ifdef RFM12_IP_SUPPORT
           _uip_buf_lock --;
           if (uip_buf_lock ()) {
             return;           /* hmpf, try again shortly
                                 (let's hope we don't miss too many ticks */
           }
           else {
               rfm12_status = RFM12_OFF;
               rfm12_rxstart();
           }
#else
           return;
#endif
        }
#endif


if (counter % 1 == 0) {
clock_tick();
}

if (counter % 5 == 0) {
ems_periodic_timeout();
ems_uart_periodic();
}

if (counter % 10 == 0) {
uip_tcp_timer();
}

if (counter % 50 == 0) {
enc28j60_periodic();
}

if (counter % 500 == 0) {
counter = 0;
uip_arp_timer();
}


#ifdef  UIP_SUPPORT
   uip_buf_unlock ();
#endif

#ifdef BOOTLOADER_SUPPORT
  if(bootload_delay) {
#ifdef DEBUG
    if(bootload_delay%50 == 0) {
      char seconds[5];
      debug_putstr("Time left to flash: ");
      itoa(bootload_delay/50, seconds, 10);
      debug_putstr(seconds);
      debug_putstr(" seconds\n");
    }
#endif
    if(-- bootload_delay == 0) {
      debug_putstr("RST\n");
      cli();
      _IVREG = _BV(IVCE);         /* prepare ivec change */
      _IVREG = 0x00;              /* change ivec */

#ifdef USE_WATCHDOG
      wdt_disable();
#endif
      void (*jump_to_application)(void) = NULL;
      jump_to_application();
    }
  }
#endif
  }
}
